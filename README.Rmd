---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = FALSE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# `{rconnection}`: a demonstration package implementing a custom connection in R

<!-- badges: start -->
[![R-CMD-check](https://github.com/coolbutuseless/rconnection/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/coolbutuseless/rconnection/actions/workflows/R-CMD-check.yaml)
<!-- badges: end -->

`{rconnection}` is a demonstration package implementing a custom connection in R `vfile()`

(`vfile()`) works similarly to the `file()` connection except it is verbose about
which connection callback is being used internally, and it has fewer features e.g.
it does not support file append or seek etc.

This code is MIT Licensed - feel free to share, fork and hack!

### Suitability of this approach for CRAN

The code to create a connection causes a `NOTE` in `R CMD check` which says:
"Found non-API call to R: ‘R_new_custom_connection’. Compiled code should not call non-API entry points in R."

As this call to `R_new_connection()` exists in R packages on CRAN, this
NOTE has been allowed through by CRAN team on some occasions.  Your results may vary.

## Installation

You can install the development version of rconnection from [GitHub](https://github.com/coolbutuseless/rconnection) with:

``` r
# install.packages("devtools")
devtools::install_github("coolbutuseless/rconnection")
```

## Using `vfile()` to read/write binary data

Write binary data to a `vfile()` connection and then read it back in.

```{r eval=FALSE}
library(rconnection)

tmp <- tempfile()
ref <- as.raw(1:255)
writeBin(ref, vfile(tmp, verbosity = 1))
tst <- readBin(vfile(tmp, verbosity = 1),  raw(), 1000)
tst
```

```{r}
library(rconnection)

tmp <- tempfile()
ref <- as.raw(1:255)
writeBin(ref, vfile(tmp, verbosity = 1))
tst <- readBin(vfile(tmp, verbosity = 1),  raw(), 1000)
tst
```


## Using `vfile()` to read/write text data

Write text to a `vfile()` connetion and then read it back in.

```{r eval = FALSE}
ref <- as.character(mtcars)
writeLines(ref, vfile(tmp, verbosity = 1))
tst <- readLines(vfile(tmp, verbosity = 1))
tst
```

```{r}
ref <- as.character(mtcars)
writeLines(ref, vfile(tmp, verbosity = 1))
tst <- readLines(vfile(tmp, verbosity = 1))
tst
```

## What is an R connection?

From [Jeroen Ooms on StackOverflow](https://stackoverflow.com/questions/30445875/what-exactly-is-a-connection-in-r)

    Connections were introduced in R 1.2.0 and described by Brian Ripley in
    the first issue of R NEWS (now called The R Journal) of  January 2001 (page 16-17) (Ref: 1)
    as an abstracted interface to IO streams such as a file, url, socket, or 
    pipe. In 2013, Simon Urbanek added a Connections.h C API (Ref: 2)
    which enables R packages to implement custom connection types, such as the 
    curl package.

    One feature of connections is that you can incrementally read or write 
    pieces of data from/to the connection using the readBin, writeBin, 
    readLines and writeLines functions. This allows for asynchronous data 
    processing, for example when dealing with large data or network 
    connections:

1. [January 2001 (page 16-17)](http://cran.r-project.org/doc/Rnews/Rnews_2001-1.pdf)
2. [[Connections.h C API](https://github.com/wch/r-source/blob/trunk/src/include/R_ext/Connections.h)]

## R Packages which implement connections

* `{rconnection}` This package! [rconnection on Github](https://github.com/coolbutuseless/rconnection)
* [zstdlite](https://github.com/coolbutuseless/zstdlite) implements a `zstdfile()` connection for read/write
  of compressed data
* [rmonocypher](https://github.com/coolbutuseless/rmonocypher) implements a `cryptfile()` 
  connection for read/write of encypted data
* [archive](https://cran.r-project.org/package=archive)
* [curl](https://cran.r-project.org/package=curl)
* And base R implements: `gzfile()`, `bzfile()`, `xzfile()`, `file()`, `url()`, 
    `unz()`, `pipe()`, `fifo()`, `socketConnection()`, `textConnection()`

## Base R functions supporting connections

`serialize()`, `saveRDS()`, `readRDS()`, `cat()`, `sink()`, `writeChar()`, 
`readChar()`, `read.csv()`, `read.delim()`, and many more.

## Documentation and write-ups on R connections

* Matthew S Shotwell's 'R Connection Internals'
    * [html](https://biostatmatt.com/R/R-conn-ints/)
    * [pdf](http://biostatmatt.com/R/R-conn-ints.pdf)


## Connection calls may be nested

Some connection objects can themselves read/write to connections e.g.
base R's `gzcon()` or the `vfile()` connection in this package.

In the following example, the `vfile()` connection will write data
to a `gzfile()` connection.

```{r}
tmp <- tempfile()
writeBin(as.raw(1:10), vfile(gzfile(tmp)))
```

Connection nesting could be useful for niche ideas like "write compressed, emcrypted data
to a socket" using:

* `zstdlite::zstdfile()` for compression
* `rmonocypher::cryptfile()` for encryption
* `socketConnection()` for writing to a socket

```{r eval = FALSE}
saveRDS(mtcars, zstdfile(cryptfile(socketConnection(...), key = "my secret")))
```




## The `Rconn` data structure

From Matthew Shotwell's documentation of the core internal R connection structure
`Rconn` copied from [his website](https://biostatmatt.com/R/R-conn-ints/C-Structures.html#C-Structures)
and included here for posterity.

    Below are the definitions for struct Rconn and struct fileconn copied from 
    src/include/Rconnections.h. Additional comments by this author (Mattheew)
    are inserted between special delimiters of the form /** comment **/. 
   
    
```
struct Rconn {
    /** class name (null terminated) **/
    char* class;

    /** description (null terminated), can be a filename, url, or other 
        identifier, depending on the connection type 
    **/
    char* description;
    int enc; /* the encoding of 'description' */

    /** file operation mode (null terminated) **/
    char mode[5];

    /** text       - true if connection operates on text
        isopen     - true if connection is open
        incomplete - used in @code{do_readLines}, @code{do_isincomplete}, 
                     and text_vfprintf, From `?connections`: true if last 
                     read was blocked, or for an output text connection whether 
                     there is unflushed output
        canread    - true if connection is readable
        canwrite   - true if connection is writable
        canseek    - true if connection is seekable
        blocking   - true if connection reads are blocking
        isGzcon    - true if connection operates on gzip compressed data 
    **/
    Rboolean text, isopen, incomplete, canread, canwrite, canseek, blocking, 
	isGzcon;

    /** function pointers for I/O operations **/


    /** open - called when the connection should be opened
        args: struct Rconn * - an initialized connection to be opened
        return: Rboolean - true if connection successfully opened, false otherwise
    **/
    Rboolean (*open)(struct Rconn *);


    /** close - called when the connection should be closed
        args: struct Rconn * - a connection to be closed
    **/
    void (*close)(struct Rconn *); /* routine closing after auto open */


    /** destroy - called after the connection is closed in order to free memory, 
        and other cleanup tasks
        args: struct Rconn * - a connection to be closed
    **/
    void (*destroy)(struct Rconn *); /* when closing connection */


    /** vfprintf - variable argument list version of printf for a connection
        args: struct Rconn * - a connection where items should be printed
              const char *   - a format string in the style of the printf family
              va_list        - a variable argument list containing the items 
                               referred to in the format string
        return: int - number of characters printed, negative on failure
    **/
    int (*vfprintf)(struct Rconn *, const char *, va_list);


 
    /** fgetc - get a (re-encoded) character from the connection
        args: struct Rconn * - a connection to be read
        return: int - a (re-encoded) character, or R_EOF
    **/
    int (*fgetc)(struct Rconn *);


    /** fgetc_internal - get a character from the connection
        args: struct Rconn * - a connection to be read
        return: int - a character, or R_EOF
    **/
    int (*fgetc_internal)(struct Rconn *);


    /** seek - seek to a new position in the connection
        args: struct Rconn * - a connection to seek
              double         - offset to seek relative to origin, apparently 
                               double is used here to avoid using 
                               integer types, i.e. long int, which is 
                               the prototype of the corresponding parameter 
                               in fseek, as defined in stdio.h
              int            - the origin of seeking, 1 (and any except 2 and
                               3) if relative to the beginning of the 
                               connection, 2 if relative to the current 
                               connection read/write position, 3 if relative to 
                               the end of the connection
              int            - currently only used by file_seek to select 
                               the read or write position when the offset is NA
        return: double - the read/write position of the connection before 
                         seeking, negative on error double is again used to 
                         avoid integer types
    **/
    double (*seek)(struct Rconn *, double, int, int);


    /** truncate - truncate the connection at the current read/write position.
        args: struct Rconn * - a connection to be truncated
    **/
    void (*truncate)(struct Rconn *);


    /** fflush - called when the connection should flush internal read/write buffers
        args: struct Rconn * - a connection to be flushed
        return: int - zero on success, non-zero otherwise
    **/
    int (*fflush)(struct Rconn *);


    /** read - read in the style of fread
        args: void *         - buffer where data is read into
              size_t         - size (in bytes) of each item to be read
              size_t         - number of items to be read
              struct Rconn * - a connection to be read
        return: size_t - number of _items_ read
    **/
    size_t (*read)(void *, size_t, size_t, struct Rconn *);


    /** write - write in the style of fwrite
        args: void *         - buffer containing data to be written
              size_t         - size (in bytes) of each item to be written
              size_t         - number of items to be written
              struct Rconn * - a connection to be written
        return: size_t - number of _items_ written
    **/
    size_t (*write)(const void *, size_t, size_t, struct Rconn *);
   
    /** cached and pushBack data
        nPushBack   - number of lines of cached/pushBack storage
        posPushBack - read position on current line of storage
        PushBack    - cached/pushBack data lines ('\n' delimited)
        save        - used to store the character following a \n, if not \r
        save2       - used to store a character from Rconn_ungetc
    **/
    int nPushBack, posPushBack; /* number of lines, position on top line */
    char **PushBack;
    int save, save2;

    /** character re-encoding with iconv
        encname   - character encoding string (null terminated), this string 
                    must be one of the standard encoding strings used by [lib]iconv
        inconv    - input character encoding context (iconv_t)
        outconv   - output character encoding context (iconv_t)
        iconvbuff - input character encoding buffer
        oconvbuff - output character encoding buffer
        next      - only used by dummy_fgetc, points to the next re-encoded 
                    character for reading
        init_out  - storage for output iconv initialization sequence 
        navail    - iconv buffer offset
        inavail   - iconv buffer offset
        EOF_signalled - true if EOF reached
        UTF8out   - true if connection writes UTF8 encoded characters
    **/
    char encname[101];
    /* will be iconv_t, which is a pointer. NULL if not in use */
    void *inconv, *outconv;
    /* The idea here is that no MBCS char will ever not fit */
    char iconvbuff[25], oconvbuff[50], *next, init_out[25];
    short navail, inavail;
    Rboolean EOF_signalled;
    Rboolean UTF8out;

    /** finalization pointers
        id     - unique id, used to "ensure that the finalizer does not 
                 try to close connection after it is alread closed"
                 (quoted from source code), but also to identify the
                 connection to be finalized. Using an arbitrary but
                 unique id here is clever, it means the connections 
                 internals are further protected from passing references 
                 to connection structures.
        ex_ptr - external pointer, referenced by finalizer code
    **/
    void *id;
    void *ex_ptr;

    /** private user data (i.e. FILE *, offsets etc.) **/
    void *private;
};
```


